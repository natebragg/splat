===============
Smudge Tutorial
===============

.. contents::

.. sectnum::

.. raw:: pdf

         PageBreak oneColumn

Simple Pinball Machine
======================

Welcome to the Smudge tutorial! This is intended for people familiar
with C and the \*nix environment. In particular, it will assume a good
knowledge of the C programming language, a working understanding of
libraries and linkers, and good facility with the command line. It is
assumed that your environment is Linux and supports pthreads. Other
environments can be made to work, but might require more advanced
knowledge.

.. sidebar:: GraphViz

   GraphViz is a prerequisite for running Smudge. If you installed
   Smudge from a .deb package, you should already have it. Otherwise,
   you may need to go get graphviz. If you don't have it, Smudge will
   exit with an error instead of generating code for you.

In this tutorial, we'll create a simple pinball game. A pinball game
has a start, a middle, and an end, and you can launch plungers, hit
targets, knock bumpers, and go down the drain, so with everything that
can happen, and all the ways it can happen, what better way to
represent a pinball machine than with a state machine?

.. figure:: 00_pinball.png
   :width: 500

The drawing above shows a state diagram for the beginnings of our
pinball game. As you can see, it starts in the *idle* state. The
*coin* event moves it to *run* and *drain* (when the ball falls
through the drain) moves it back to idle.

The Smudge source code for the above machine is shown below:

.. code-block:: c
   :include: 00_pinball.smudge
   :linenos:

This shows the basic structure of a Smudge state machine. The machine is called
``pinball`` and its states (``idle`` and ``run``)
are listed inside the curly brackets. The ``*`` before ``idle``
indicates that it's the initial state. Events are handled in each
state with an arrow (``-->``) that shows which state will be next when
that event is received. 

Generate Code
-------------

This is a pretty simple pinball machine, but let's see if we can get
it to compile before doing something more complicated. First, we need
a file that has ``main`` in it.

.. code-block:: c
   :include: 00_main.c
   :linenos:

That's about as minimal a C file as we can have and still use
Smudge. We'll talk about what all the lines do later, but for now the
important thing is to have ``SRT_HANDLERS`` called for every state
machine. Since there's only one, and it's called ``pinball``, we have
the above ``SRT_HANDLERS(pinball)``.

Now to build the whole thing into an executable.

::

   $ make 00_pinball
   /usr/bin/smudge --dot-fmt=Png 00_pinball.smudge
   Wrote file "00_pinball.png"
   Wrote file "00_pinball.h"
   Wrote file "00_pinball.c"
   Wrote file "00_pinball_ext.h"
   gcc -Wall -Werror -Wextra -Wno-unused-parameter -ggdb3 \
   -I/home/nathan/smear/include -c -o 00_pinball.o 00_pinball.c
   gcc -Wall -Werror -Wextra -Wno-unused-parameter -ggdb3 \
   -I/home/nathan/smear/include -c -o 00_main.o 00_main.c
   gcc -L/home/nathan/smear -o 00_pinball 00_pinball.o 00_main.o \
   -lsmear -pthread

   $ ./00_pinball

Hooray, it compiles and does nothing! Before we start sending events,
let's briefly go over all those commands and what they do. First, and
most simply, there's

::

   /usr/bin/smudge --dot-fmt=Png 00_pinball.smudge

This just runs Smudge on our source file and tells it to format the
picture with the state diagram as a **.png**. This command generates
several files:

 * 00_pinball.png
 * 00_pinball.h
 * 00_pinball.c
 * 00_pinball_ext.h


The only .c file, **pinball.c**, actually implements the state
machine. Everything else (except the picture) is an
interface. **00_pinball_ext.h** is the interface to the functions
provided by the runtime environment. You don't have to worry about
these, just know that they're provided by ``SRT_HANDLERS`` and
**libsmear.a**. **00_pinball.h** is the interface to your state
machine. It has prototypes for functions generated by Smudge.  We'll
see how to use these functions in the next section.

::
   
   gcc -Wall -Werror -Wextra -Wno-unused-parameter -ggdb3 \
   -I/home/nathan/smear/include -c -o 00_pinball.o 00_pinball.c
   gcc -Wall -Werror -Wextra -Wno-unused-parameter -ggdb3 \
   -I/home/nathan/smear/include -c -o 00_main.o 00_main.c
   gcc -L/home/nathan/smear -o 00_pinball 00_pinball.o 00_main.o \
   -lsmear -pthread

The rest of these commands are just compiling the generated
**00_pinball.o**, the tiny **00_main.o**, and linking everything
together along with Smear. You can see that I have **libsmear.a** in
my **/home/nathan/smear** directory, and **smear.h** is in
**/home/nathan/smear/include**. If you have Smear checked out like I
do, you can do the same thing with your link and include paths. If you
installed Smear system-wide, you can leave out those paths.

Events
------

Once the whole thing is built, we run the generated **00_pinball** and
it produces no output. Let's see if we can change it to actually
respond to some events. First, let's switch to example 1 (which has
the same Smudge source as 0) and run Smudge on it.

::

   $ smudge 01_pinball.smudge

It generated the files we saw before (with a different image format
for the diagram). Let's look more closely at **01_pinball.h**.

.. code-block:: c
    :include: 01_pinball.h
    :linenos:
       
The important lines here are 22 and 24, which define the *coin* and
*drain* events from our Smudge file. Don't worry about their arguments
for now; we can just send NULL pointers. Also useful for debugging
(and demonstrating things in tutorials) is the
``pinball_Current_state_name`` function. It returns a string
containing the name of the machine's current state.

Let's write a new **01_main.c** to use these functions.

.. code-block:: c
   :include: 01_main.c
   :linenos:

And when we compile and run this program, we get:

::

   $ ./01_pinball 
   Sending coin event.
   Starting runtime.
   Current state: idle
   Waiting for events to be handled.
   Current state: run
   Sending drain event.
   Current state: run
   Waiting for events to be handled.
   Current state: idle

Note how the events aren't actually processed until the
``SRT_wait_for_idle()`` call returns. This is because Smudge code runs
in a multithreaded environment. You can send an event from any thread,
but it won't be handled until the operating system switches out that
thread's context and executes the Smudge runtime environment (thus
``SRT``) which receives the events and moves the state machine
forward. You can rely on the operating system to do this for you, or
you can explicitly wait until all the pending events have been
handled. That second option is what the ``SRT_wait_for_idle`` function
does. It acts like a fence in that all events sent before it are
handled before it returns.

.. sidebar:: Smear, the runtime environment

   We've mostly glossed over all the ``SRT_`` functions getting called
   in our example **main.c** programs. SRT stands for Smear RunTime,
   and it does a lot of the work of actually making our state machines
   run. The functions called in all of the example **main.c** programs
   are defined and documented in **smear.h**.

   By itself, Smudge generates very system-agnostic code. That means
   it needs the user to implement certain functions for event queueing
   and dispatch, as well as error handling and memory management. You
   can see these functions all listed in **01_pinball_ext.h**.

   When you link against Smear with ``-lsmear``, you're getting all
   these ``SMUDGE_`` functions defined for you. The call to
   ``SRT_HANDLERS(pinball)`` defines ``pinball_Send_Message`` in a way
   that works with the rest of Smear's implementation.

   This tutorial uses Smear because implementing all those functions
   is a distraction. However, Smudge just relies on those functions in
   **01_pinball_ext.h** being defined and having certain
   semantics. Smear (and this tutorial) depends on things from the
   POSIX environment, but there's no reason why Smudge code can't be
   ported to a system that doesn't support pthreads. In fact, when
   Smudge was originally developed, the target system didn't look
   anything like POSIX.


Error Handling
--------------

If we add a call to ``pinball_drain(NULL)`` before the last
``SRT_wait_for_idle()`` call in **01_main.c** (on line 37), we get
**02_main.c**.  Since the *drain* event is not handled when the
*pinball* machine is in the *idle* state, this generates an error and
returns early:

::

   $ ./02_pinball 
   Sending coin event.
   Starting runtime.
   Current state: idle
   Waiting for events to be handled.
   Current state: run
   Sending drain event.
   Current state: run
   Waiting for events to be handled.
   Current state: idle
   pinball[idle]: Unhandled event "drain"
   $ echo $?
   255

We won't be generating a lot of errors in this tutorial, but it's
important to know how they're handled. Isn't that a nice message? It
tells you the current state and the received event.

Side Effects
============

Our pinball machine looks cool, but it doesn't actually do
anything. All that happens when you send an event is a state
transition, but the only thing we know about different states is that
they can handle different events. Enter side effects, to make your
state machines do stuff.

@functions
----------

The first kind of side effect we're going to talk about is called an
@function. It is so named because in the Smudge source, it begins
with the ``@`` character, and it calls a C function that you will
write. Let's add a new event to the *run* state to increase the
player's score every time the ball hits a target.

.. code-block:: c
   :include: 03_pinball.smudge
   :linenos:

There are two new things in this example: an @function called
``incScore``, and the dash. Dashes are just like arrows, except they
don't cause state transitions. I know, you're thinking to yourself
that this new ``-(...)-`` thing is way different, because in addition
to not having a ``>`` at the end, it's got this side effect stuff
surrounded by parentheses. Well, it turns out that the syntax for an
arrow is actually ``-(side-effect-list)->`` and that ``-->`` is
shorthand for ``-()->``. Likewise, there's a dash shorthand: ``--`` is
the same as ``-()-``. It just silently ignores the event in question.

Running **smudge** on this new example gives us the expected
**03_pinball...** files. However, if you look at **02_pinball_ext.h**
and **03_pinball_ext.h**, you'll see a difference: there's a new
function prototype for ``incScore`` in there. If you try to compile
with the same stuff that's in **02_main.c**, you'll se a linker
error. It wants that ``incScore`` function to be defined. Let's do
that.

.. code-block:: c
   :include: 03_main.c
   :linenos:

Running this new program gives us the expected

::

   $ ./03_pinball
   ding ding, new score: 1
   ding ding, new score: 2

.. sidebar:: Names

   You may have noticed that names of states use hyphens to separate
   words while names of events and @functions use camel case. In the
   case of @functions, the reason is obvious. The names given in
   Smudge source are literal C identifiers and only valid C
   identifiers make valid @function names.

   Event names get turned into C identifiers, but not directly. Valid
   event names include all sorts of crazy things like
   ``World's-best-event`` and ``"The system is
   down!"``. Unfortunately, sending events like this in C gets
   tricky. Since ``"The system is down!"`` isn't a valid C identifier,
   Smudge mangles its name into something that's both valid C and
   uniquely maps back to the real name. To send ``"The system is
   down!"`` from C, you would have to call a function called
   ``pinball_The_20_system_20_is_20_down_21__19__``. However, error
   messages for unhandled events will still print the unmangled event
   name. So for events that are strictly internal to Smudge, non-C
   names are fine.

   State machine names should be valid C identifiers for similar
   reasons, but state names are never seen as raw identifiers outside
   of Smudge's generated code. So it's fine to name your states things
   like ``prepare-ball``. The ``Current_state_name`` for your state
   machine will always return the real name.

Enter/Exit Effects
------------------

So now we can have side effects, that's cool. They also give us a
reason to be in different states, since we can react to the same event
with different side effects depending on which state we're in. There's
another place we can put side effect lists: before we enter a state
and after we leave it. These are called enter/exit functions. Let's
use some to make our pinball machine a little more flashy.

.. code-block:: c
   :include: 04_pinball.smudge
   :linenos:

Here in **04_pinball.smudge**, we've gone nuts with the
@functions. The new *prepare-ball* state executes 3 of them when it's
entered. Note that Smudge guarantees that @function side effects will
be executed in the order they're listed. The *run* state here
demonstrates why *target* doesn't look like ``target -(@incScore)->
run``. If it did, it would execute the exit-function then the
enter-function for *run*. That may be desirable in some instances, but
it's not in this one.

Let's make a **04_main.c** to go with this. Nothing new here, just a
whole lot of events getting sent and handled.

.. code-block:: c
   :include: 04_main.c
   :linenos:

And when it's built and run:

::

   $ ./04_pinball
     1	Locking paddles.
     2	Dropping ball.
     3	Unlocking paddles. Whirrrrrr
     4	Ding ding ding ding ding
     5	DingDing
     6	Awwwwwww
     7	Score: 2
     8	A new high score!
     9	Locking paddles.
    10	Dropping ball.
    11	Unlocking paddles. Whirrrrrr
    12	Ding ding ding ding ding
    13	DingDingDingDingDingDingDingDingDingDingDing[...]
    14	Awwwwwww
    15	Score: 100
    16	A new high score!
    17	Locking paddles.
    18	Dropping ball.
    19	Unlocking paddles. Whirrrrrr
    20	Ding ding ding ding ding
    21	Ding
    22	Awwwwwww
    23	Score: 1
    24	High score: 100
    25	Locking paddles.

Timers
------

Now that we have users, they've started doing bad and unexpected
things to our pinball machine. Someone figured out they could lift the
front of the machine to prevent the ball from dropping and get cheaty
high scores.

Fortunately for us, there's a tilt sensor in our pinball machine. All
we have to do is hook up the event to our Smudge machine.

.. code-block:: c
   :include: 05_pinball.smudge
   :linenos:

This uses the enter and exit events we just talked about to guarantee
that the timer is limited in scope to the ``lockout`` state. All
that's left is to implement the timers.

Now we get to make use of the fact that Smear has support for
cancellable timers. To use it, we call ``SRT_delayed_send()`` with the
name of the state machine, the name of the event, a pointer to the
event payload (NULL for now, explained later), and a delay in
milliseconds. This function returns a ``cancel_token_t``, which gets
used later exactly once in a call to ``SRT_cancel``.

.. code-block:: c
   :include: 05_main.c
   :linenos:

If you call ``SRT_cancel`` before the timer expires, the event won't
fire. If you call it after the timer expires, nothing bad will
happen. It is important to call ``SRT_cancel`` eventually, though,
because in addition to canceling the timer, it cleans up some internal
resources that are allocated for it.

In **05_main.c** on lines 18 and 23, we can see how these features are
used.

This way, we can ignore all of the player's events for a little while
to give them some time to think about whether or not cheating at
pinball is a winning strategy for life.

One more thing: Up to now, we've been calling ``SRT_wait_for_idle()``
to drain the events out of the machine. Since that function is
designed to be used in a mainloop, it doesn't wait for timers to
expire before returning. That's useful in a lot of situations, but
here we actually do want to just sit around doing nothing in ``main``
until all the events have been handled. That's what
``SRT_wait_for_empty()`` does in **05_main.c** on line 142.

Default Handlers
================

That timer was great, but explicitly ignoring every single event that
could possibly happen is verbose and error prone. If we added a new
event, we'd have to remember to put it in *lockout* or there would
be a bug.

Any-Event
---------

Lucky for us, Smudge comes with a handy feature called the
*any-event*. It's a special event, spelled ``_``, that catches all
events not explicitly listed in the state. You can see it in action in
**06_pinball.smudge**.

.. code-block:: c
   :include: 06_pinball.smudge
   :linenos:

Any-State
---------

This is pretty nice, but would-be cheaters are now complaining about
machines eating their money. The complaint goes like this: First, they
lift up the machine to try to get extra points. The game detects this
and locks them out. While they're waiting for the tilt timer to
expire, they shove more coins in. Of course, we're ignoring the coin
event, so it ends up getting lost in the machine and eaten.

Meh, those people got what they deserved. There is a real problem,
though, and it's that players who insert 2 coins in rapid succession
lose their second coin to the bitbucket.

So let's reject coins in states other than *idle*. As a moderately
unfortunate side effect, coins in the *lockout* state will be rejected
too. I suppose that's alright. At least it will reduce the number of
complaints we have to hear from cheaters.

Oh, and we should probably use the tilt sensor in all the states, not
just while the game is running.

.. code-block:: c
   :include: 07_pinball.smudge
   :linenos:

That's better. Now, what's going on here? There's a new state called
``_`` and it's handling the tilt and coin events. Just like the
*any-event*, this is the *any-state*. It handles events for states
that don't explicitly handle them. You can also put an *any-event* in
the *any-state* if you never want to get an unhandled event error.

In this instance, we're rejecting coins whenever they're inserted
(other than while idle) and locking the machine if it gets a tilt
while not already locked out.

You might be wondering how we know how a given event will be handled,
if there's a handler for it in the *any-state* and the state it's in
handles the *any-event*. For that, we have this lovely prioritized
table:

+-------+-------+
| state | event |
+=======+=======+
| named | named |
+-------+-------+
|  any  | named |
+-------+-------+
| named |  any  |
+-------+-------+
|  any  |  any  |
+-------+-------+

So if an event comes in and it's handled with a named event handler in
the machine's current state, it's always handled there. Named event
handlers in the *any-state* are checked next, followed by *any-event*
handlers in the current state. That means that if we get a *tilt*
event in the *lockout* state, it will be ignored by the handler in
*lockout* instead of causing us to re-enter *lockout*. Likewise,
*coin* events are handled in *idle* directly and rejected anywhere else.

The last place it looks is the *any-event* in the *any-state*, just
like a ``default`` clause in a ``switch`` statement. Unlike switches
in C, though, if no handler is found for an event Smudge will cause an
error.


Transient States
================

We've started hearing reports of another bug: The paddles get locked
when the machine turns on, and unlocked when the ball is placed at the
plunger, but they're not being locked when the machine tilts. People
are continuing to play, even though they can't get points, during the
tilt lockout period.

They're also still tilting the machine a lot. I think maybe if we zero
out their score upon *tilt* they might stop.

.. code-block:: c
   :include: 08_pinball.smudge
   :linenos:

You can see on line 4 we've added an ``initialize`` state. Transient
states take this ``state -(side-effect-list)-> next-state`` form. They
don't handle any events, since the state machine transitions out of a
transient state as soon as it's entered. Just like with exit events,
any events sent as a side effect of going through a transient state
will be handled in the next state.

Multiple Machines
=================

Smudge is doing a pretty great job of handling state. Right now we
have this paddle lock function that sets some state somewhere off
screen. Let's instead turn it into its own Smudge state machine.

.. code-block:: c
   :include: 09_pinball.smudge
   :linenos:

This new *flippers* machine will handle all the paddle events. If
they're unlocked, the flippers will flip. If not, they won't. Pretty
simple, right? The only really new thing here, aside from putting more
than one state machine in a file, is how they
communicate. ``flippers.lock`` and ``flippers.unlock`` are sent from
the *pinball* game's state machine to the *flippers* state machine as
side effects. The general syntax for this kind of thing is
``destination-machine.event``. If you're sending an event within a
machine, you can omit the ``destination-machine`` part.

Since *flippers* is a new state machine, our **09_main.c** has to
invoke the ``SRT_HANDLERS`` macro again for it. Here's an example
program that uses everything we've seen so far:

.. code-block:: c
   :include: 09_main.c
   :linenos:

Note the ``SRT_wait_for_idle`` call on line 125. It's there because we
have state machines sending messages around to each other so we can't
just queue up all our events and let loose.

Event Payloads
==============

This machine is looking pretty good. The only thing wrong with it is
that all the targets are worth the same number of points (1). Other
pinball games have higher point values for harder to reach targets.

To add this feature, we don't have to touch the Smudge code at
all. Instead, we use this argument that we've been passing to all our
events. So far it's always been ``NULL`` but what if we want to put
something there? Let's take a look at the definition of
``pinball_target`` in **10_pinball.h**.

.. code-block:: c

   // in 10_pinball.h
   typedef struct pinball_target_t pinball_target_t;
   void pinball_target(const pinball_target_t *);
   // and in 10_pinball_ext.h
   extern void incScore(const pinball_target_t *);

Well that's not very illuminating. What Smudge did here was generate
an incomplete type so that ``pinball_target`` would take a particular
type. That type of thing is what our ``incScore`` @function accepts,
so we can be sure the event payload came along unchanged. Since it's
an incomplete type definition, we have to define what goes in it
before we can use it. Here's a simple little struct definition that we
can use to send a score along with our *target* events.

.. code-block:: c

   struct pinball_target_t
   {
       int value;
   };

While we're at it, let's make a function that returns a new
target. The runtime expects event payloads to be pointers to memory
allocated with ``malloc`` so let's give it that.

.. code-block:: c

    static pinball_target_t *newTarget(int val)
    {
        pinball_target_t *tgt;
        tgt = malloc(sizeof(*tgt));
        if (tgt != NULL)
            tgt->value = val;
        return tgt;
    }

**10_main.c** uses this function to send different targets with
different point values. Note that when using Smear, event payloads
like this are always freed after being handled, so you really do need
to call ``malloc`` for each event that gets sent.
